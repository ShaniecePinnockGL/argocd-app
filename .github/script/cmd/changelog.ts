import {
  ENVIRONMENT_FILES_REGEX,
  IEnvironmentFile,
  applicationNameToRepo,
  getAllEnvironmentFiles,
  readLocalFile,
  refFromVersion,
} from '../lib/common';
import {
  compareCommits,
  createOrUpdateCommentWithFooter,
  deleteCommentWithFooterIfExists,
  getCommit,
} from '../lib/github';
import {info, setFailed, warning} from '@actions/core';
import {getChangedFiles, readFileAtBase} from '../lib/git';
import {defaultSanitizer} from '../lib/util';
import {parse} from 'yaml';

enum ChangeType {
  ADDED,
  MODIFIED,
  DELETED,
}

const footer =
  '> This changelog was automatically generated by a Github Actions Workflow based on information provided in this PR. If this message is inaccurate, please reach out on the #team-tools-help channel\n';

async function main() {
  const changedFiles = await getChangedFiles();

  const changedEnvironmentFiles = changedFiles
    .map(f => ENVIRONMENT_FILES_REGEX().exec(f))
    .filter(f => f !== null)
    .map(f => ({
      file: f![0],
      domain: f!.groups?.domain,
      project: f!.groups?.project,
      toString: () => `${f!.groups?.domain}/${f!.groups?.project}`,
    }));

  if (changedEnvironmentFiles.length === 0) {
    info('No changed environment files.');
    await deleteCommentWithFooterIfExists(footer);
    return;
  }

  if (changedEnvironmentFiles.length > 1) {
    throw new Error(
      'Only one environment can be updated at a time. Environments updated were ' +
        changedEnvironmentFiles.join(',')
    );
  }

  const allEnvironmentFiles = await getAllEnvironmentFiles();

  const environmentFile = changedEnvironmentFiles[0];
  info('Getting changes for ' + environmentFile);

  const [original, current] = await Promise.all([
    readFileAtBase(environmentFile.file),
    readLocalFile(environmentFile.file),
  ]);

  const parsedOriginal = parse(original) as IEnvironmentFile;
  const parsedCurrent = parse(current) as IEnvironmentFile;

  const changes = new Array<{
    type: ChangeType;
    application: string;
    fromVersion?: string;
    toVersion?: string;
  }>();

  for (const originalApp of parsedOriginal.applications) {
    const currentApp = parsedCurrent.applications.find(
      a => originalApp.name === a.name
    );

    if (!currentApp) {
      info(`${originalApp.name} has been removed`);
      changes.push({
        type: ChangeType.DELETED,
        application: originalApp.name,
        fromVersion: originalApp.version,
      });
      continue;
    }

    if (currentApp.version !== originalApp.version) {
      info(
        `${originalApp.name} has been updated from ${originalApp.version} to ${currentApp.version}`
      );
      changes.push({
        type: ChangeType.MODIFIED,
        application: originalApp.name,
        fromVersion: originalApp.version,
        toVersion: currentApp.version,
      });
    }
  }

  const addedApps = parsedCurrent.applications.filter(
    app =>
      !parsedOriginal.applications.some(original => original.name === app.name)
  );
  addedApps.forEach(app => {
    info(`${app.name} has been added`);
    changes.push({
      type: ChangeType.ADDED,
      application: app.name,
      toVersion: app.version,
    });
  });

  if (changes.length === 0) {
    info('No changes to report');
    await deleteCommentWithFooterIfExists(footer);
    return;
  }

  let markdown = `### Changes made to \`${environmentFile}\` in this PR:\n\n`;

  for (const change of changes) {
    if (change.type === ChangeType.ADDED) {
      markdown += `#### :new: ${change.application} has been added\n`;
    } else if (change.type === ChangeType.DELETED) {
      markdown += `#### :no_entry: ${change.application} has been removed\n`;
    } else if (change.type === ChangeType.MODIFIED) {
      const repo = `GreenlightMe/${applicationNameToRepo(change.application)}`;
      const fromRef = refFromVersion(change.fromVersion!);
      const toRef = refFromVersion(change.toVersion!);

      try {
        info(
          `Getting commits for ${repo} between ${change.fromVersion} to ${change.toVersion}`
        );
        const {commits, html_url} = await compareCommits(repo, fromRef, toRef);

        markdown += `#### :checkered_flag: ${change.application} has been updated from \`${change.fromVersion}\` to \`${change.toVersion}\` ([${commits.length} changes](${html_url}))\n`;
        markdown += `> ${allEnvironmentFiles
          .filter(([, f]) => f.project !== environmentFile.project)
          .map(([{domain, project}, f]) => {
            const version = f.applications.find(
              a => a.name === change.application
            )?.version;
            if (!version) return null;
            else
              return `\`${version}\` is deployed to \`${domain}/${project}\``;
          })
          .filter(l => l !== null)
          .join(', ')}\n`;

        const commitsByAuthor = commits.reduce((a, c) => {
          if (c.author) {
            if (!a.has(c.author.login)) {
              a.set(c.author.login, [c]);
            } else {
              a.set(c.author.login, a.get(c.author.login)!.concat(c));
            }
          }
          return a;
        }, new Map<string, typeof commits>());

        for (const [author, commits] of commitsByAuthor.entries()) {
          markdown += `* @${author} (${commits.length} changes):\n`;
          for (const commit of commits) {
            let message = commit.commit.message.split('\n', 1)[0];
            message = message.replace(
              /\(#(\d+)\)/g,
              `([#$1](https://github.com/${repo}/pull/$1))`
            );

            const commitLink = `[[${commit.sha.substring(0, 7)}](${
              commit.html_url
            })]`;

            markdown += `  * ${commitLink} ${message}\n`;
          }
        }
      } catch (e) {
        markdown += `#### :warning: ${change.application} has been updated from \`${change.fromVersion}\` to \`${change.toVersion}\` (unknown changes) :warning:\n`;
        warning(`${change.application} had an error getting diff: ${e}`);

        const [from, to] = await Promise.allSettled([
          getCommit(repo, fromRef),
          getCommit(repo, toRef),
        ]);

        if (from.status === 'rejected') {
          warning(`${fromRef} didn't exist: ${from.reason}`);
          markdown += `* \`${change.fromVersion}\` (${fromRef}) does not exist in ${repo}`;
        }

        if (to.status === 'rejected') {
          warning(`${toRef} didn't exist: ${to.reason}`);
          markdown += `* \`${change.toVersion}\` (${toRef}) does not exist in ${repo}`;
        }
      }
    }
    markdown += '\n';
  }
  markdown = defaultSanitizer(markdown);
  await createOrUpdateCommentWithFooter(markdown, footer);
}

main().catch((err: Error) => {
  setFailed(err);
});
