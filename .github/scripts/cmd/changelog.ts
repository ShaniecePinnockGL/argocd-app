import { parse } from 'yaml';
import { setFailed } from '@actions/core';
import * as core from '@actions/core';

import { getChangedFiles, readFileAtBase } from '../library/git';
import { applicationNameToRepo, ENVIRONMENT_FILES_REGEX, getAllEnvironmentFiles, IEnvironmentFile, readLocalFile, refFromVersion } from '../library/common';
import { compareCommits, createOrUpdateCommentWithFooter, getCommit } from '../library/github';

enum ChangeType { ADDED, MODIFIED, DELETED }

const footer = '> This changelog was automatically generated by a Github Actions Workflow based on information provided in this PR. If this message is inaccurate, please reach out on the #team-tools-help channel\n'

async function main() {
    const changedFiles = await getChangedFiles()

    const changedEnvironmentFiles = changedFiles
        .map((f) => ENVIRONMENT_FILES_REGEX().exec(f))
        .filter((f) => f != null)
        .map((f) => ({
            file: f[0],
            domain: f.groups.domain,
            project: f.groups.project,
            toString: () => `${f.groups.domain}/${f.groups.project}`
        }))

    if (changedEnvironmentFiles.length == 0) {
        core.info('No changed environment files.');
        return;
    }

    if (changedEnvironmentFiles.length > 1) {
        throw new Error('Only one environment can be updated at a time. Environments updated were ' + changedEnvironmentFiles.join(','))
    }

    const allEnvironmentFiles = await getAllEnvironmentFiles();

    const environmentFile = changedEnvironmentFiles[0]
    core.info('Getting changes for ' + environmentFile)

    const [
        original, current
    ] = await Promise.all([
        readFileAtBase(environmentFile.file),
        readLocalFile(environmentFile.file)
    ])

    const parsedOriginal = parse(original) as IEnvironmentFile;
    const parsedCurrent = parse(current) as IEnvironmentFile;

    const changes = new Array<{ type: ChangeType, application: string, fromVersion?: string, toVersion?: string }>();

    for (const originalApp of parsedOriginal.applications) {
        const currentApp = parsedCurrent.applications.find((a) => originalApp.name == a.name)

        if (!currentApp) {
            core.info(`${originalApp.name} has been removed`);
            changes.push({ type: ChangeType.DELETED, application: originalApp.name, fromVersion: originalApp.version })
            continue;
        }

        if (currentApp.version != originalApp.version) {
            core.info(`${originalApp.name} has been updated from ${originalApp.version} to ${currentApp.version}`);
            changes.push({ type: ChangeType.MODIFIED, application: originalApp.name, fromVersion: originalApp.version, toVersion: currentApp.version })
        }
    }

    const addedApps = parsedCurrent.applications.filter((app) => !parsedOriginal.applications.some((original) => original.name == app.name))
    addedApps.forEach((app) => {
        core.info(`${app.name} has been added`);
        changes.push({ type: ChangeType.ADDED, application: app.name, toVersion: app.version })
    })

    if (changes.length == 0) {
        core.info("No changes to report");
        return;
    }

    let markdown = `### Changes made to \`${environmentFile}\` in this PR:\n\n`

    for (const change of changes) {
        if (change.type == ChangeType.ADDED) {
            markdown += `#### :new: ${change.application} has been added\n`
        }
        else if (change.type == ChangeType.DELETED) {
            markdown += `#### :no_entry: ${change.application} has been removed\n`
        }
        else if (change.type == ChangeType.MODIFIED) {

            const repo = `GreenlightMe/${await applicationNameToRepo(change.application)}`;
            const fromRef = await refFromVersion(change.fromVersion);
            const toRef = await refFromVersion(change.toVersion);

            try {
                core.info(`Getting commits for ${repo} between ${change.fromVersion} to ${change.toVersion}`)
                const { commits, html_url } = await compareCommits(
                    repo,
                    fromRef,
                    toRef
                )

                markdown += `#### :checkered_flag: ${change.application} has been updated from \`${change.fromVersion}\` to \`${change.toVersion}\` ([${commits.length} changes](${html_url}))\n`
                markdown += `> ${allEnvironmentFiles.map(([{ domain, project }, f]) => {
                    const version = f.applications.find((a) => a.name == change.application)?.version
                    if (!version) return null;
                    else return `\`${version}\` is deployed to \`${domain}/${project}\``
                }).filter((l) => l != null).join(', ')}\n`

                const commitsByAuthor = commits.reduce((a, c) => {
                    if (!a.has(c.author.login)) a.set(c.author.login, [])
                    a.set(c.author.login, a.get(c.author.login).concat(c))
                    return a;
                }, new Map<string, typeof commits>())

                for (const [author, commits] of commitsByAuthor.entries()) {
                    markdown += `* @${author} (${commits.length} changes):\n`
                    for (const commit of commits) {
                        let message = commit.commit.message.split('\n', 1)[0]
                        message = message.replace(/\(\#(\d+)\)/g, `([#$1](https://github.com/${repo}/pull/$1))`)

                        const commitLink = `[[${commit.sha.substring(0, 7)}](${commit.html_url})]`;

                        markdown += `  * ${commitLink} ${message}\n`
                    }
                }
            }
            catch (e) {
                markdown += `#### :warning: ${change.application} has been updated from \`${change.fromVersion}\` to \`${change.toVersion}\` (unknown changes) :warning:\n`
                core.warning(`${change.application} had an error getting diff: ${e}`)

                const [from, to] = await Promise.allSettled([
                    getCommit(repo, fromRef),
                    getCommit(repo, toRef)
                ])

                if (from.status == "rejected") {
                    core.warning(`${fromRef} didn't exist: ${from.reason}`)
                    markdown += `* \`${change.fromVersion}\` (${fromRef}) does not exist in ${repo}`;
                }

                if (to.status == "rejected") {
                    core.warning(`${toRef} didn't exist: ${to.reason}`)
                    markdown += `* \`${change.toVersion}\` (${toRef}) does not exist in ${repo}`;
                }
            }
        }
        markdown += `\n`
    }

    await createOrUpdateCommentWithFooter(markdown, footer);
}

main().catch((err: Error) => {
    core.error(err.stack)
    setFailed(err)
})