import { parse } from 'yaml';
import { setFailed } from '@actions/core';
import * as core from '@actions/core';

import { getChangedFiles, readFileAtBase } from '../library/git';
import { applicationNameToRepo, ENVIRONMENT_FILES_REGEX, IEnvironmentFile, readLocalFile, refFromVersion } from '../library/common';
import { compareCommits, createComment, editComment, getAllComments, getUser } from '../library/github';

enum ChangeType { ADDED, MODIFIED, DELETED }

const footer = '> This changelog was automatically generated by a Github Actions Workflow based on information provided in this PR. If this message is inaccurate, please reach out on the #team-tools-help channel\n'

async function main() {
    const changedFiles = await getChangedFiles()
    // const changedFiles = ['gl/values-prod.yaml'];
    const changedEnvironmentFiles = changedFiles
        .map((f) => ENVIRONMENT_FILES_REGEX.exec(f))
        .filter((f) => f != null)
        .map((f) => ({
            file: f[0],
            domain: f.groups.domain,
            project: f.groups.project,
            toString: () => `${f.groups.domain}/${f.groups.project}`
        }))

    if (changedEnvironmentFiles.length == 0) {
        core.info('No changed environment files.');
        return;
    }

    if (changedEnvironmentFiles.length > 1) {
        throw new Error('Only one environment can be updated at a time. Environments updated were ' + changedEnvironmentFiles.join(','))
    }

    const environmentFile = changedEnvironmentFiles[0]
    core.info('Getting changes for ' + environmentFile)

    const [
        original, current
    ] = await Promise.all([
        readFileAtBase(environmentFile.file),
        readLocalFile(environmentFile.file)
    ])

    const parsedOriginal = parse(original) as IEnvironmentFile;
    const parsedCurrent = parse(current) as IEnvironmentFile;

    const changes = new Array<{ type: ChangeType, application: string, fromVersion?: string, toVersion?: string }>();

    for (const originalApp of parsedOriginal.applications) {
        const currentApp = parsedCurrent.applications.find((a) => originalApp.name == a.name)

        if (!currentApp) {
            core.info(`${originalApp.name} has been removed`);
            changes.push({ type: ChangeType.DELETED, application: originalApp.name, fromVersion: originalApp.version })
            continue;
        }

        if (currentApp.version != originalApp.version) {
            core.info(`${originalApp.name} has been updated from ${originalApp.version} to ${currentApp.version}`);
            changes.push({ type: ChangeType.MODIFIED, application: originalApp.name, fromVersion: originalApp.version, toVersion: currentApp.version })
        }
    }

    const addedApps = parsedCurrent.applications.filter((app) => !parsedOriginal.applications.some((original) => original.name == app.name))
    addedApps.forEach((app) => {
        core.info(`${app.name} has been added`);
        changes.push({ type: ChangeType.ADDED, application: app.name, toVersion: app.version })
    })

    if (changes.length == 0) {
        core.info("No changes to report");
        return;
    }

    let markdown = `### Changes made to \`${environmentFile}\` in this PR:\n\n`

    for (const change of changes) {
        if (change.type == ChangeType.ADDED) {
            markdown += `#### :new: **${change.application} has been added**\n`
        }
        else if (change.type == ChangeType.DELETED) {
            markdown += `#### :no_entry: **${change.application} has been removed**\n`
        }
        else if (change.type == ChangeType.MODIFIED) {

            const repo = `GreenlightMe/${await applicationNameToRepo(change.application)}`;

            const { commits, html_url } = await compareCommits(
                repo,
                await refFromVersion(change.fromVersion),
                await refFromVersion(change.toVersion)
            )

            markdown += `#### :checkered_flag: **${change.application} has been updated from \`${change.fromVersion}\` to \`${change.toVersion}\` ([${commits.length} changes](${html_url}))**\n`

            const commitsByAuthor = commits.reduce((a, c) => {
                if (!a.has(c.author.login)) a.set(c.author.login, [])
                a.set(c.author.login, a.get(c.author.login).concat(c))
                return a;
            }, new Map<string, typeof commits>())

            for (const [author, commits] of commitsByAuthor.entries()) {
                markdown += `* @${author} (${commits.length} changes):\n`
                for (const commit of commits) {
                    let message = commit.commit.message.split('\n', 1)[0]
                    message = message.replace(/\(\#(\d+)\)/g, `([#$1](https://github.com/${repo}/pull/$1))`)

                    const commitLink = `[[${commit.sha.substring(0, 7)}](${commit.html_url})]`;

                    markdown += `  * ${commitLink} ${message}\n`
                }
            }
        }
        markdown += `\n`
    }

    markdown += footer

    core.info("Getting all comments to see if I should create a new one or edit an existing one")
    const allComments = await getAllComments();
    const possiblyExistingComment = allComments.find((c) => c.body.includes(footer));

    if (possiblyExistingComment && (await getUser()).id == possiblyExistingComment.user.id) {
        core.info("Found existing comment to edit (" + possiblyExistingComment.id + ")")
        await editComment(possiblyExistingComment.id, markdown)
    }
    else {
        core.info("Creating new comment")
        await createComment(markdown)
    }
}

main().catch((err: Error) => {
    core.error(err.stack)
    setFailed(err)
})